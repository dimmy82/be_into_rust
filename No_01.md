# rustにハマる巻01  

## 1． rustはどんな言語  

  高速かつ安全、多くの設計＆実装ミスなど潜在的なバグはコンパイル時点で検知してくれる言語です。
  
## 2． 色々なメモリの管理仕組み

  - 手動でallocate/free （C、、、他は全然思い付かない）
    - バグ無しで実装することはスーパーエンジニアしかできない
      - freeし忘れたら、memory leak
      - freeが早かったら、予期せぬエラー
      - freeがダブったら、予期せぬエラー
  - garbage collection （Jvm系、Haskellなど）
    - 手抜き、めっちゃ楽
    - Full GCが発生したら再起動しかない
  - 自動的にスコープから外れたら直ちに解放 （**rust**、C++ RAII patterns）

## 3． rustのメモリ管理

#### メモリは用途によって２種類に分類：

| ＼ | Stack | Heap |
|:---|:---|:---|
|**アクセス方法** |FILO |一定な領域が確保できる任意な場所 |
|**格納対象** |サイズ固定なデータ |サイズ変動可能なデータ |
|-------- | - 全ての整数型（i32, u32など） | - サイズ固定以外のデータ（Stringなど） |
|-------- | - 全ての小数型（f64など） |-------- |
|-------- | - bool, char |-------- |
|-------- | - 上記タイプを含むTuple：(i32, bool) |-------- |

## 4． 所有権

```rust
{                      　　　　　　　  // スコープ開始
    let s1 = String::from("hello");  // s1が生成された（メモリ確保された）
    // 「hello」という文字列の所有権はs1に与えている
    // s1は使える
}                                    // スコープ終了、s1が無効になる（メモリ解放された）
```

#### 実際メモリに格納したイメージ：

- メモリ解放： Stackにある所有権に従ってHeapも一緒にfreeされる

<img src="https://doc.rust-lang.org/book/img/trpl04-01.svg" width="50%">

### 4-1． 所有権の移譲： Move

```rust
    let s1: String = String::from("hello");
    {
        let s2: String = s1;     // 所有権はs1からs2にmoveした
    }
    println!("{}, world!", s1);  // s1は無効なのでコンパイルエラーになる
```

#### コンパイル結果: 

```rust
error[E0382]: use of moved value: `s1`
  --> src/main.rs:22:28
   |
20 |         let s2 = s1;
   |             -- value moved here
21 |     }
22 |     println!("{}, world!", s1);
   |                            ^^ value used here after move
   |
   = note: move occurs because `s1` has type `std::string::String`, which does not implement the `Copy` trait
```

#### 実際メモリに格納したイメージ：

<img src="https://doc.rust-lang.org/book/img/trpl04-04.svg" width="50%">

### 4-2． Stackコピー： Copy trait

```rust
    let i1: i32 = 100;
    {
        let i2: i32 = i1;        // 所有権の移譲は発生せず、i1のcopyをi2に与えた
    }                            // i2のみ解放される
    println!("number: {}", i1);  // i1はそのまま使える
    
    // これも同じく通る
    let t1: (i32, bool) = (1, true);
    {
        let t2: (i32, bool) = t1;
    }
    println!("{}, {}", t1.0, t1.1)
```

- **Stackのみ必要**なデータは、所有権の移譲とデータの複製は実質同じ処理になるため、

### 4-3． 完全コピー： Clone trait

```rust
    let s1: String = String::from("hello");
    {
        let s2: String = s1.clone();        // 所有権の移譲は発生せず、s1のcloneをs2に与えた
    }                                       // s2のみ解放される
    println!("{}, world!", s1);             // s1はそのまま使える
```

#### 実際メモリに格納したイメージ：

<img src="https://doc.rust-lang.org/book/img/trpl04-03.svg" width="50%">

#### Clone trait の実現：

```rust
    #[derive(Clone)]
    struct Data {
        pub value: String
    }

    let d1: Data = Data { value: String::from("hello, data") };
    {
        let d2: Data = d1.clone();
    }
    println!("{}", d1.value);
```
